## 특징
- key / value 스토어
- 컬렉션 지원
    - List, Set, SortedSet, Hash 자료구조
- Pub / Sub 지원
- 디스크 저장
    - rdb와 aof 기능 지원
- 복제
    - 마스터 / 슬레이브 구조
- 빠른 속도
    - 1초당 100,000 QPS 수준의 높은 성능 제공

## 디스크 저장

- RDB, AOF 둘 다 사용하는 것이 좋다고 이야기 하지만, 디스크를 사용해서 저장하는 만큼 성능 손실은 어느정도 감수해야한다.

### RDB

- 현재 메모리에 대한 덤프를 생성하는 기능
- 레디스는 싱글 스레드이기 때문에 rdb저장을 위해 fork를 통해서 자식 프로세스를 생성한다.
- RDB 저장을 위한 ‘save’와 ‘bgsave’가 존재
- save : 모든 작업을 멈추고 현재 메모리 상태에 대한 RDB 파일 생성, 해당 시간동안 아무런 작업을 할 수 없다
- bgsave : 백그라운드에서 현재 메모리 상태에 대한 RDB 파일 생성, 실제로 자식 프로세스를 생성하는 fork 작업을 통해 자식 프로세스에서 RDB 파일 저장

### AOF (Append Only File)

- 데이터를 저장하기 전에 AOF 파일에 현재 수행해야할 명령을 미리 저장해두고, 장애가 발생하면 AOF를 기반으로 복구
  1. 클라이언트가 Redis에 업데이트 관련 명령 요청
  2. Redis는 해당 명령을 AOF에 저장
  3. 파일 쓰기가 완료되면 실제로 해당 명령을 실행해서 메모리의 내용 변경
- appendfsync
    - AOF를 파일에 저장할 때, OS가 파일 쓰기 시점을 결정하여 파일을 버퍼 캐시(메모리)에 저자하고 적절한 시점에 이 데이터를 저장하는 시점
    - always : AOF 값을 추가할 때마다 fsync를 호출해서 디스크에 실제 쓰기
    - everysec : 매초마다 fsync를 호출해서 디스크에 실제 쓰기
    - no : OS가 실제 sync를 할 때까지 따로 설정하지 않는다

## vs Memcache

|  | Memcache | Redis |
| --- | --- | --- |
| 속도 | 100,000 QPS 이상 | 100,000 QPS 이상 |
| 자료구조 | key / value 만 | 컬렉션 지원 |
| 안정성 | 장애 거의 없음 | 특성을 잘못 이해할 경우, 프로세스 장애 |
| 저장 | 캐시 솔루션 | 캐시솔루션 + 디스크 저장 (rdb, aof |
| 응답속도 | 전체적으로 균일 | Memcache보다 상대적으로 떨어짐 |

## 싱글 스레드 주의사항

### keys 명령어

- 몇십만개, 몇백만개, 몇천만개가 넘어가면 해당 작업에 아주 많은 시간을 소모, 다른 요청은 전혀 처리되지 않는다. ⇒ 장애 발생

### flushall / flushdb 명령어

- 모든 데이터를 삭제하는 명령어
- flushall  : db에 모든 키 삭제
- flushdb : db 통으로 삭제
- select [db 번호]

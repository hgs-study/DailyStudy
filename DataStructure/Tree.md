### 이진 트리
-----
   + 시간 복잡도 logN
      + https://neos518.tistory.com/145 


### B-Tree
-------
   + https://helloinyong.tistory.com/296
   + Tree 구조
      + ![image](https://user-images.githubusercontent.com/76584547/120010995-c4e4a900-c018-11eb-9578-a696e671b46e.png)
   ```
   - 일반적인 Tree는 평균적으로 탐색에 대한 시간 복잡도로 O(logN)
   ```
   + 최악의 Tree 구조
      + ![image](https://user-images.githubusercontent.com/76584547/120011198-ff4e4600-c018-11eb-8a9a-67940927f108.png)
   ```
   - 만약 트리 노드의 요소가 위처럼 한쪽 방향으로만 쏠려있다면 최악의 탐색 시간은 O(N)
   - 이러한 경우를 방지하기 위해 우리는 밸런스 트리(Balanced Tree)를 이용
   ```
   + 밸런스 트리(Balanced Tree)
   ```
   - 트리의 노드가 한 방향으로 쏠리지 않도록, 노드 삽입 및 삭제 시 특정 규칙에 맞게 재 정렬되어 왼쪽과 오른쪽 자식 양쪽 수의 밸런스를 유지하는 트리이다. 
   - 항상 양쪽 자식의 밸런스를 유지하므로, 무조건 O(logN)의 시간 복잡도를 가지게 된다.
   - 다만 재정렬되는 작업으로 인해 노드 삽입 및 삭제 시 일반적인 트리보다 성능이 떨어지게 된다. 
   - 그러므로 밸런스 트리는 삽입/삭제의 성능을 희생하고 탐색에 대한 성능을 높였다고 볼 수 있다. 
   - 밸런스 트리는 대표적으로 RedBlack-Tree, B-Tree가 있다.
   ```
   + 해시 테이블
   ```
   - 모든 자료구조와 그 어떤 알고리즘을 비교해도 탐색 시간이 가장 빠른 것은 바로 해시 테이블이다.
   - 해시 테이블은 해시 함수를 통해 나온 해시 값을 이용하여 저장된 메모리 공간에 한 번에 접근을 하기 때문에 O(1)이라는 시간 복잡도를 가진다
   - 데이터를 찾는 시간 복잡도는 O(1)이지만 등호를 (=, >)을 사용하면 매우 비효율적이다.
   - 모든 값이 정렬되어 있지 않으므로 특정 기준보다 크거나 작은 값을 찾을 수 없다.
   - 찾을 수는 있지만 O(1)을 보장되지 않으며 매우 비효율적이다.
   ```

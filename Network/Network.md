## 1% 네트워크 원리
---

### 네트워크의 전체 모습
```
  브라우저 : XXX라는 페이지의 데이터를 주십시오.
  웹서버 : 예 알겠습니다. 이것이 그 데이터입니다.
```

```
  브라우저 : 이 주문 데이터를 처리해주세요
  웹 서버 : 예 주문 데이터를 받았습니다.
```

```
  브라우저 요청 <-> 웹서버 응답
```
![image](https://user-images.githubusercontent.com/76584547/152686731-d208c072-9dd4-4a69-9810-44c66de1dcf3.png)

+ 패킷이 거치는 경로
![image](https://user-images.githubusercontent.com/76584547/152688673-b8bfaf39-6b88-4cf3-a5f8-9ed457810373.png)
![image](https://user-images.githubusercontent.com/76584547/152688690-8e13675a-eec9-4ccb-9837-9322367915bf.png)

+ 네트워크는 어떻게 접속되는가?
![image](https://user-images.githubusercontent.com/76584547/152688701-026d9cca-a7e0-4b8b-ad25-3ab2a6a48efc.png)


### 탐험 여행의 경유지

#### 1. HTTP 리퀘스트 메세지를 작성한다.
---
  1. 탐형 여행은 URL 입력부터 시작한다
    + URL
      ```
        - http:// 뿐만 아니라 ftp:, file:, mailto:, news: 등의 url이 있다.
        - http와 ftp를 보면 프로토콜을 나타내는구나 생각할 수 있는데 file 같이 네트워크를 사용하지 않는 것도 있으므로 프로토콜이라고 단언할 수는 없다. 
        - '액세스 방법'이라는 식으로 생각하는 것이좋다.
      ```
  2. 브라우저는 먼저 URL을 해독한다.
    + URL 해독
      ```
        http: + // + 웹서버명 + / + 디렉토리명 + / + ... + 파일명 
      ```
  3. 파일명을 생략한 경우
    + 파일명 생략
      ```
        - http://www.lab.cyber.co.kr/dir/
        - 하지만 파일명을 쓰지 않으면 어느 파일에 액세스해야 할지 모른다.
        - 이럴 경우 보통, 대부분의 서버가 /dir/index.html, /dir/default.html로 설정해둔다
      ```
  #### 브라우저가 가장 먼저 하는 일은 URL을 해독하는 것이다.
  
  4. HTTP의 기본 개념
    + HTTP 프로토콜 
      ```
        - 클라이언트와 서버가 주고 받는 메시지의 내용이나 순서를 정한 것
        - 보통 클라이언트가 서버에게 "무엇을" "어떻게 해서" 하겠다는 내용을 요청한다.
        - URI : "무엇을" / 메서드 : "어떻게 해서"
      ```

#### 2. 웹서버의 IP주소를 DNS서버에 조회한다.
---
  + HTTP의 메세지를 만들면 다음에는 이것을 OS에 의뢰하여 액세스 대상의 웹서버에게 송신한다.

#### HTTP 헤더
---
![image](https://user-images.githubusercontent.com/76584547/152807387-be3c427f-a032-47ca-b9a7-efae55b5fcd9.png)

![image](https://user-images.githubusercontent.com/76584547/152807423-9dbd199b-e894-4f8b-a2c2-131222b84239.png)

#### 서브넷
---
  ```
    - TCP/IP는 서브넷이라는 작은 네트워크를 라우터로 접속해서 전체 네트워크가 만들어진다고 생각할 수 있다.
    - 여기서 말하는 서브넷은 허브에 몇대의 PC가 접속된 것이라고 생각하고 이것을 한 개의 단위로 생각하여 "서브넷"이라고 부르고, 라우터에서 연결하면 네트워크 전체가 완성된다.
  ```
![image](https://user-images.githubusercontent.com/76584547/153009173-fd41167b-a13c-4312-9f71-b37d4e7450a1.png)


#### IP
---
![image](https://user-images.githubusercontent.com/76584547/153008790-dbb55a23-4977-4727-a0bc-5e7dda7b8105.png)
![image](https://user-images.githubusercontent.com/76584547/153008851-b595a83c-99b6-4346-8612-f991b48d1d0a.png)
```
  IP 주소의 호스트 번호
  - 모두 0 : 서브넷 자체를 의미한다.
  - 모두 1 : 서브넷에 있는 기기 전체에 패킷을 보내는 "브로드캐스트"를 나타낸다.
```

#### DNS
---
```
  - IP주소는 DNS서버에서 조회해야한다.
  - DNS 서버의 클라이언트로 동작한다고 말할 수 있고, 이는 "DNS 리졸버" 또는 "리졸버"라고 부른다.
  - DNS의 원리를 사용하여 IP주소를 조사하는 것을 "네임 리졸루션"(name resolution, 이름확인)
  - 이 리졸루션을 사용하는 것이 "리졸버"이다.
```

+ 설정
```
  - DNS 서버에 메세지를 송신할 때도 DNS 서버의 IP주소가 필요합니다.
  - 단, 이것은 TCP/IP 설정 항목의 하나하나로 컴퓨터에 미리 설정되어 있으므로 다시 조사할 필요는 없습니다.
```

#### Socket 라이브러리
----
```
  - OS에 포함되어 있는 네트워크 기능을 애플리케이션에서 호출하기 위한 라이브러리
  - 도메인명에서 IP 주소를 조사할 때 브라우저는 Socket 라이브러리의 리졸버를 사용한다.
```

+ 리졸버 동작

![image](https://user-images.githubusercontent.com/76584547/153016024-4700b34a-07f7-4631-b17c-4f39e068aa61.png)

  1. [애플리케이션(브라우저)] gethostbyname(URL) 메서드 호출
  2. [Socket] 조회 메세지(URL)을 OS 내부의 프로토콜 스택에 보낸다
  3. [프로토콜 스택] UDP메시지 송신
  4. [프로토콜 스택] LAN 어댑터
  5. [프로토콜 스택] DNS 서버
  6. [프로토콜 스택] LAN 어댑터
  7. [프로토콜 스택] UDP메세지 쉰
  8. [Socket] 응답 메세지를 메모리(변수)에 저장
  9. [애플리케이션(브라우저)] 도착


#### 3. 전 세계의 DNS 서버가 연대한다.
---
  1. DNS 서버의 기본 동작
  ```
    - 클라이언트에서 조회 메세지를 받고 조회의 내용에 응답하는 형태로 정보를 회답한다.
    - 조회 메세지에는 세 가지 정보가 포함되어있다.
  ```
  + 이름
    + 서버나 메일 배송 목적지(메일주소에서 @ 뒷부분의 이름)와 같은 이름
  + 클래스
    + DNS의 구조를 고안했을 때 인터넷 이외에도 네트워크에서의 이용까지 검토하여 이것을 클래스라는 정보를 준비했지만 현재는 인터넷 외의 네트워크는 없기 때문에 클래스는 항상 인터넷을 나타내는 'IN'을 사용한다.
  + 타입
    + 이름에 어떤 타입(종류)가 지원되는지 나타낸다. 예를 들어 타입이 A이면 이름에 IP주소가 지원되는 것을 나타내며, MX이면 이름에 메일 배송 목적지가 지원된다는 것
    
  2. 도메인의 계층
    + 여러 데이터 분산
      ```
        - 정보를 분산시켜서 다수의 DNS 서버에 등록하고, 다수의 DNS 서버가 연대하여 어디에 정봅가 등록되어 있는지 찾아내는 구조
      ```
      + 계층적으로 도메인을 DNS서버에 저장한다
      ```
      ㅇ www.cyber.co.kr일 경우
        - 최상위 kr : 대한민국
        - co : 회사
        - cyber : 회사 도메인명

        - kr -> co -> cyber로 갈수록 하위도메인
      ```
  3. 담당 DNS 서버를 찾아 IP주소를 가져온다
    + 하위 도메인을 담당하는 DNS서버의 IP주소를 그 상위의 DNS서버에 등록한다.
      ```
      ㅇ lab.glasscom.com일 경우
        - lab.glasscom.com의 IP주소를 glasscom.com DNS 서버에 등록한다.
        - glasscom.com의 IP주소를 com DNS 서버에 등록한다.
      ```
      
      + 루트 도메인(com,jp 등)의 DNS 서버를 인터넷에 존재하는 모든 DNS 서버에 전부 등록한다.
        + 이렇게 하면 어느 DNS 서버도 루트 도메인에 액세스할 수 있다.
        + 그 결과 클라이언트에서 어딘가의 DNS서버에 액세스하면 여기서부터 루트 도메인을 경유하여 도메인의 계층 아래로 찾아가서 최종적으로 원하는 DNS 서버에 도착한다.

  4. DNS 서버 캐시 사용
    + DNS 서버는 한 번 조사한 이름을 캐시에 기록할 수 있는데, 조회한 이름에 해당하는 정보가 캐시에 있으면 그 정보를 회답하기 때문
      + 캐시한 위치에서 계층 구조를 아래로 향하여 찾을 수 있다.
      + 주의점 : 캐시에 정보를 저장한 후 등록 정보가 변경되는 경우도 있으므로 캐시 안에 저장된 정보는 올바르다고 단언할 수 없다. 


#### 프로토콜 스택에 메세지 송신을 의뢰한다.
----
  1. 데이터 송 수신 동작 개요
  + OS 내부의 프로토콜 스택에 메세지 송신 동작을 의뢰할 때는 Socket 라이브러리 프로그램 부품을 결정된 순번대로 호출한다.

  ![image](https://user-images.githubusercontent.com/76584547/153428578-e9740e7e-1856-4426-9bad-1c493009b93d.png)

  ```
    - 실제로는 먼저 서버측에서 소켓을 만들고, 소켓에 클라이언트가 파이프를 연결하기 기다립니다.
  ```
  + OS 내부의 프로토콜 스택이 하는 역할
    1. 소켓을 만듭니다 (소켓 작성 단계)
    2. 서버측의 소켓에 파이프를 연결합니다. (접속 단계)
    3. 데이터 송수신합니다. (송수신단계)
    4. 파이프를 분리하고 소켓을 말소합니다 (연결 끊기 단계)
    
  2. 소켓 작성 단계
    + 소켓은 애플리케이션과 프로토콜 스택 사이에서 네트워크 송수신을 호출합니다.
    + 디스크립터
      + 소켓이 생기면 디스크립터라는 것이 돌아오므로 애플리케이션은 이것을 받아서 메모리에 기록합니다.
      + 예를 들어 창을 2개 열어서 웹서버에 도잇에 액세스하면 소켓이 2개가 생기고 이 2개의 소켓을 식별해야하는데 이 소켓 하나하나에 할당한 번호를 디스크립터라고 합니다.   
      + 소켓을 만든 후 디스크립터를 이용하여 접속 동작이나 데이터 송수신 동작을 실행하는데 이때 디스크립터를 보여주면 프로토콜 스택이 어느 소켓을 사용하여 접속할지 또는 데이터를 송수신할지 금방 알 수 있습니다.
    
  3. 파이프를 연결하는 접속 단계 
    + 소켓의 connect를 호출하면 프로토콜 스택이 접속하는 동작 실행
      + 접속할떄 디스크립터(소켓), ip주소, 포트번호가 필요하다
  4. 메세지를 주고 받는 송 수신 단계
    + 소켓이 상대측과 연결되면 데이터를 쏟아부으면 상대측 소켓에 데이터가 도착한다.
      + socket의 write 호출
        + write를 호출할 때는 디스크립터와 송신 데이터를 지정 -> 프로토콜 스택이 송신 데이터를 서버에 송신
      + socket의 read 호출
        + 메세지가 돌아오면 수신한 응답 메세지를 저장하기 위한 메모리 영역을 지정하는데 이 메모리 영역을 "수신 버퍼"라고 부른다.
        + 그러면 read가 받아서 수신버퍼에 응답 메세지를 저장한다.
  5. 연결 끊기 단계에서 송수신이 종료된다.
    + socket의 close 호출
      + 브라우저가 데이터 송수신을 완료하면 socket의 close를 호출
      + 소켓 사이를 연결한 파이프와 같은 것은 분리되고 소켓도 말소된다.
      + HTTP프로토콜에서 응답 메세지의 송신을 완료했을 떄 웹서버측에서 연결 끊기 동작을 실행하므로 먼저 웹서버측에서 close를 호출하여 끊는다.
      ```
        HTTP 프로토콜은 HTML문서나 영상 데이터를 별도의 것으로 취급하여 하나하나 데이터를 읽을 때마다
        "접속"-> "리퀘스트 메세지 송신" -> "응답 메세지 수신" -> "연ㄴ결끊기"라는 동작을 반복한다.
      ```
      + 하지만 이것은 비효율이기 때문에 HTTP 1.1에서는 리퀘스트해야할 데이터가 없어진 상태에서 연결 끊기를 사용할 수 있다.
    

#### 기타 
----
+ 네트워크 도중 리퀘스트나 응답이 삭제되거나 파괴될 수 있는 사태를 고려해야한다.
```
  - 리퀘스트나 응답의 실체는 전기나 빛의 신호이기 때문에, 그 신호가 잡음 등의 영햘을 받아 파괴될 수 있다.
  - 리퀘스트나 응답은 모두 0과 1로 이루어진 디지털 데이터이므로 데이터를 목적지까지 운반하는 구조
```
+ 웹 서버에 사진이 3개 있는 경우
```
  - html 파일을 읽기 위해 리퀘스트 요청한다. 응답 받는다.
  - 사진 3개의 요청을하고 3개의 응답을 받는다.
  - 총 4번의 요청과 응답을 한다.
```

#### www.hgsssss.naver.com 으로 가는법 (나혼자 정리)
---
1. 웹브라우저에서 www.naver.com을 친다.
2. socket 라이브러리에서 DNS에 보내는 조회 메세지를 만든다.
3. OS 내부의 프로토콜 스택에 메세지를 보낸다.
4. 프로토콜 스택은 LAN 어댑터로 메세지를 준다.
5. LAN 어댑터는 가장 가까운 DNS서버에 메세지를 준다.
6. 가장 가까운 DNS 서버는 메세지를 루트 도메인 서버에 전송한다.
7. (하위)com DNS 서버에 전송한다.
8. (하위)naver.com DNS 서버에 전송한다.
9. (하위)hgsssss.naver.com DNS 서버에 전송한다.
10. www.hgsssss.naver.com 의 IP주소를 가장 가까운 DNS서버에 전송하여 클라이언트에게 회답한다.

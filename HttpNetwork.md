## HTTP
``` 
 - Stateless : 무상태 프로토콜
```

+ Stateless
  - HTTP는 무상태(Stateless)프로토콜이다.
  - 클라이언트와 서버가 요청과 응답을 주고 받으면 연결이 끊어진다.
  - 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다.
  - 클라이언트와 서버는 서로 상태를 유지하지 않는다.

## IP / TCP / UDP
생각나는 대로 정리하는 중
+ IP :
  - 클라이언트에서 서버로 요청을 보낼 때 많은 노드를 거치게 되는데 서버가 켜져 있는지 안 켜져 있는지 확인도 안 한채 요청을 보낸다.
  - 서버가 꺼져있는 경우 클라이언트 요청은 많은 노드를 통해 서버에 도착하고 나서야 알게 된다.
  - 불안정하다.
  
+ TCP :
  - 3Way Handshake 통해 서버가 요청을 받을 수 있는지 확인한다.
  - SYN -> SYN+ACK -> ACK 순으로 클라이언트 ->서버 , 서버->클라, 클라->서버 순으로 요청을 받을 수 있는지 확인 한 후 데이터를 전송한다 
    (최근엔 최적화가 많이 되어 있기 때문에 ACK할 때 데이터를 보낸다.)
  - 연결 지향적, 신뢰성
  - 패킷정보가 클 경우 잘라서 보내는데 순서가 뒤죽박죽으로 서버한테 도달하면 서버는 다시 제대로 뒤죽박죽된 곳부터 제대로 보내달라고 재요청한다.
    (이유 : TCP에 순서 정보가 들어있기 때문)
  - 순서 상대적으로 
    
+ UDP :
  - IP프로토콜과 똑같다.
  - UDP는 IP 프로토콜 + PORT + 체크섬 기능이 있다.
  - 최근엔 UDP를 점점 쓰는 추세. 커스텀마이징 or 최적화를 하려면 TCP는 이미 많은 기능들을 들고 있지만 UDP는 가지고 있는 것이 없기 때문에 애플리케이션 쪽에서 기능을 추가해 커스텀마이징한다.
  - 속도 빠름

## 일반 정보 헤더
```
- From : 유저 에이전트의 이메일 정보
- Referer : 이전 웹 페이지 주소
- User-Agent : 유저 에이전트 애플리케이션 정보
- Server : 요청을 처리하는 오리진 서버의 소프트웨어 정보
- Date : 메시지가 생성된 날짜
```

+ From : 
  - 일반적으로 잘 사용하진 않음, 검색엔진 같은 곳에서 주로 사용
  - 요청에서 사용

+ Referer : 
  - 정말 많이 사용함
  - 이전 웹 페이지의 주소
  - 유입 경로 분석 가능
  - 요청에서 사용
  
+ User-Agent(클라이언트 애플리케이션):
  - 클라이언트 접속 브라우저 정보
  - 통계 정보
  - 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능
  - 요청에서 사용
  
+ Server :
  - 요청을 처리하는 Origin 서버(프록시서버,캐시서버를 제외한 실제 api를 받는 서버)의 소프트웨어 정보
  - 응답에서 사용
  
+ Date :
  - 메시지가 발생한 날짜와 시간
  - 응답에서 
  
  
## 특별한 정보 헤더
```
- Host : 요청한 호스트 정보(도메인)
- Location : 페이지 리다이렉션
- Allow : 허용 가능한 HTTP 메서드
- Retry-After : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
```

+ Host (필수값)
  - 정말 중요!!!!(필수 값)
  - 요청한 호스트 정보(도메인)
  - 하나의 서버가 여러 도메인을 처리해야 할 때(가상 호스트)
  - 200.200.200.2에 여러 도메인이 묶여 있을 경우(aaa.com,bbb.com,ccc.com) 사용자가 GET /hello를 보냈을 때 어떤 도메인에 api를 보낼지 구분해줌
  
+ Location
  - 페이지 리다이렉션
  - 웹 브라우저 3xx 응답 결과일 때 Location 헤더가 있으면, Location 위치로 자동 이동
  - 201 (Created): Location 값은 요청에 의해 생선된 리소스 URI
  - 3xx (Redirection) : Location 값은 요청을 자동으로 리디렉션하기 위한 대상 리소스를 가리킴
  
+ Allow
  - 허용 가능한 HTTP 메서드
  - 405 (Method Not Aolled)에서 응답에 포함해야함
  - Allow: GET, HEAD, PUT (POST로 보낼시 GET으로 보내야함)
  - 사실 서버에 잘 구현되어있지 않음
  
+ Retry-Ater
  - 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
  - 503 (Service Unavailable) : 서비스가 언제까지 불능인지 알려줄 수 있음
  - 날짜 표기 / 초 단위 표기 가능


## 인증 헤더
```
- Authorization : 클라이언트 인증 정보를 서버에 전달
- WWW-Authenticate : 리소스 접근 시 필요한 인증 방법 정의
```

+ Authorization
  - 클라이언트 인증 정보를 서버에 전달
  - Basic xxxxxxxxxxx
  - 인증 메커니즘 여러가지가 있음 (Oauth2 등등)
  - 코인 거래소 api를 사용할 때 본인 확인을 위한 인증 등
  - 사용자 토큰 인증요청 -> header.add("Authorization", "Basic " + base64Creds);
  
+ WWW-Authenticate
  - 리소스 접근 시 필요한 인증 방법 정의
  - 401 Unauthorized 응답과 함께 사용

## Cookie
  - 사용자가 로그인시 서버가 setCookie(ex:홍길동)를 하여 클라이언트 브라우저 쿠키 저장소에 쿠키(ex:홍길동)를 저장하여 앞으로 모든 요청에 쿠키를 세팅하여 서버는 이 쿠키 값을 읽어서 사용자가 누군지 판별
  
  + 사용처
    - 사용자 로그인 세션 관리 (로그인시 set-cookie : sessionId="123~ADASD!@#" 세션 아이디를 세팅하여 서버는 누군지 판별 가능)
    - 광고 정보 트래킹
    
  + 쿠키 정보는 항상 서버에 전송됨
    - 네트워크 트래픽 추가 유발
    - 최소한의 정보만 사용(세션id, 인증토큰)
    - 서버에 전송하지 않고 웹 브라이저 내부에 데이터를 저장하고 싶으면 웹 스트로지 (localStorage, sessionStorage)참고
    
  + 주의!
    - 보안에 민감한 데이터는 저장하면 안됨 (주민번호, 신용카드 번호 등)
    
  + 생명 주기 (Expires, max-age)
    - Set-Cookie : expires = Sate, 26-Dec-2020 04:39:21 GMT
      -> 만료일이 되면 쿠키 삭제
    - Set-Cookie : max-age = 3600(3600초)
      -> 0이나 음수를 지정하면 쿠키 삭제
    - 세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료시까지만 유지
    - 영속 쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유지
    
  + 도메인 (Domain)
    - 예) domain - example.org
    - 명시 : 명시한 문서 기준 도메인 + 서브 도메인 포함
      - domain = example.org를 지정해서 쿠키 생성
        -> example.org는 물론이고
        -> dev.example.org도 쿠키 접근
        
    - 생략 : 현재 문서 기준 도메인만 적용
      - example.org에서 쿠키를 생성하고 domain 지정을 생략
        -> example.org에서만 쿠키 접근
        -> dev.example.org는 쿠키 미접근
        
  + 경로 (Path)
    - 예) path =/home
    - 이 경로를 포함한 하위 경로 페이지만 쿠키 접ㅈ근
    - 일반적으로 path = / 루트로 지정
    - 예)
      - path=/home 지정
        -> /home o
        -> /home/level1 o
        -> /home/lv1/lv2 o
        -> /hello x
        
  + 보안 (Secure, HttpOnly, SameSite)
    - Secure
      -> 쿠키는 http, https를 구분하지 않고 쿠키를 전송한다.
      -> 하지만 Secure 설정을 하면 https일때만 쿠키를 전송한다.
      
    - HttpOnly
      -> XSS공격 방지
      -> 자바스크립트에서 접근 불가 (document.cookie)
      -> Http 전송에만 사용
      
    - SameSite
      -> XSRF 공격 방지
      -> 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송

## 캐시
```
 - 캐시 없을 때
   -> 데이터가 변경되지 않아도 계속 네트워크를 통해 데이터를 다운로드를 받아야한다.
   -> 인터넷 네트워크는 매우 느리고 비싸다 / 브라우저 로딩 속도가 느리다 /  느린 사용자 경험
   
 - 캐시 있을 때
   -> http 헤더에 cache-control :max-age = 60을 넣어줄 수 있음 (60초 유효)
   -> 빠르다 / 브라우저 캐시를 먼저 찾음
   
 - 캐시 시간 초과
   -> 다시 서버에 요청을 해서 데이터 받고 캐시를 갱신한다.
   -> 네트워크 다운로드가 다시 발생한다.
```

 + 캐시 시간 초과
  - 캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다.
   1. 서버에서 기존 데이터를 변경함 (1.jpg -> 2.jpg)
   2. 서버에서 기존 데이터를 변경하지 않음 (1.jpg)
   3. 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법 필요!!!
   
 + 검증 헤더 (조건부 요청)
  - Last-Modified : 2020년 11월 10일 10:00:00 (최종 수정일)
  - 캐시 시간이 초과돼서 클라이언트가 다시 요청을 보낼 때 if-modified-since라는 헤더에 2020년11월10일 10:00:00로 보내면 서버에서 마지막 수정일을 확인해서 변경된 게 없으면 304 Not Modified를 내보낸다. Http Body는 빼버리고 Http Header만 보내서 304 Not modified를 보냄.
  - 클라이언트는 캐시에 저장되어 있는 데이터 재활용 가능
  - 요청 헤더에(if-modified-since) 넣어서 수정된 데이터인지 확인.
  - 요청 받은 서버는 마지막 수정일이 같으면 304 Not Modified 아니면, 새로운 데이터를 보냄
  
  
 + 검증 헤더와(Last-Modified,ETag) 조건부 요청
  - if-modified-since : last-modified 사용
   => 단점 :
      - 1초 미만(0.x초) 단위로 캐시 조정이 불가능 (최대 초단위 : 2020년 10월 15일 10:00:00)
      - 날짜 반의 로직 사용
      - 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
      - 서버에서 별도의 캐시 로직을 관리하고 싶은 경우 (스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우)
  - if-none-match : ETag 사용
   => ETag (Entity Tag)
     - 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
      예) ETag : "v1.0",ETag : "a2asdksnj2sd3"
     - 데이터가 변경되면 이 이름을 바꾸어서 변경함 (Hash를 다시 생성)
      예) ETag : "aaaa"-> ETag : "bbb"
     - 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기
  - 조건이 만족하면 200 ok
  - 조건이 만족하지 않으면 304 not modified
  
## 캐시 제어 헤더
```
   - Cache-Control : 캐시 제어
   - Pragma : 캐시 제어 (하위 호환)
   - Expires :캐시 유효 기간 (하위 호환)
```

+ Cache-Control : 캐시 지시어(directives)
 - Cache-Control : max-age
  => 캐시 유효 시간, 초 단위
 - Cache-Control : no-cache
  => 데이터는 캐시해도 되지만, 항상 원(origin)서버에 검증하고 사용
 - Cache-Control : no-store
  => 데이터에 민감한 정보가 있으므로 저장하면 안됨
   (메모리에서 사용하고 최대한 빨리 삭제)
   
+ Pragma : 캐시 제어 (하위 호환)
 - Pragma : no-cache
 - HTTP 1.0 하위 호환 (지금은 거의 사용하지 않음)
 
+ Expires : 캐시 만료일 지정(하위 호환)
 - expires : Mon, 01 Jan 1990 00:00:00 GMT
 - 정확한 날짜로 지정
 - HTTP 1.0부터 사용
 - 지금은 더 유연한 Cache-Control : max-age 사용 권장(초단위)
 - Cache-Control:max-age와 함께 사용하면 Expires는 무시
 

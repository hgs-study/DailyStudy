## Stream
----
```
  데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소
```
  + 특징
    + 선언형 : 더 간결하고 가독성이 좋아진다.
    + 조립할 수 있음 : 유연성이 좋아진다.
    + 병렬화 : 성능이 좋아진다.


### 컬렉션 vs 스트림
-----
```
  공통점 : 컬렉션과 스트림 모두 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공
  
  차이점 : 데이터를 언제 계산하느냐가 가장 큰 차이
```

  + 컬렉션
    + 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 구조 
    + 컬렉션의 모든 요소를 메모리에 저장해야 하며 컬렉션에 추가하려는 요소ㅓ는 미리 계산되어야한다. 
    + 적극적 생성 : 모든 값을 계산할 때까지 기다림
    + 외부 반복 : 명시적으로 컬렉션 항목을 하나씩 가져와서 처리
  
  + 스트림
    + 요청할 때만 요소를 계산하는 고정된 자료구조 
    + 사용자가 요청하는 값만 스트림에서 추출하는 것이 핵심
    + 게으른 생성 : 필요할 때만 값을 계산
    
    
  ```
  ㅇ외부 반복 vs 내부 반복
  
  외부 반복(컬렉션)
    - 명시적으로 컬렉션 항목을 하나씩 가져와서 처리
    - 병렬성 스스로 관리해야한다
    
  내부 반복(스트림)
    - 반복을 알아서 처리해주고 결과값을 어딘가에 저장해준다
    - 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리
       
  ```
  
  
### 스트림 연산
----
```
  ㅇ 중간연산
  ㅇ 최종연산
```

+ 중간 연산
```
  - filter, map, limit 등 서로 연결되어 다른 스트림을 연결
  - 게으름, 단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다.
```

+ 최종 연산
```
  - 스트림 파이프 라인에서 결과를 도출한다.
  - 보통 List, Integer, void 등 스트림 이외의 결과가 반환
```


### 스트림 활용
```
  ㅇ filter
  ㅇ distinct
```

+ filter : 일치하는 요소 반환
```java
        //filter 프레디케이트
        List<Dish> vegetarianMenu = menu.stream()
                                        .filter(Dish::isVegetarian)
                                        .collect(Collectors.toList());
```
  
+ distinct : 중복 제거
```java
        //고유 요소 필터링 (distinct)
        List<Dish> distinctMenu = menu.stream()
                                        .filter(d -> d.getName().equals("pizza"))
                                        .distinct()
                                        .collect(Collectors.toList());
```


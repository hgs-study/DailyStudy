## Kafka#2

### 프로듀서 파티셔너란?
---
```
  - 프로듀서가 데이터를 보내면 무조건 파티셔너를 통해서 브로커로 데이터가 전송되게 된다.
  - 파티셔너는 토픽의 어떤 파티션에 넣을지 결정하는 역할을 한다.
```

![image](https://user-images.githubusercontent.com/76584547/125187297-e072de80-e269-11eb-8652-237209fa72ac.png)

+ 레코드에 포함된 메시지 키 또는 메시지 값에 따라서 파티션의 위치가 결정된다.
+ 프로듀서를 사용할 때 파티셔너를 따로 설정하지 않으면 UniformStickyPartitioner로 설정된다.

```
  ㅇ UniformStickyPartitioner
    - 메시지 키가 있을 때와 없을 때 다르게 동작한다.
    - 메시지 키가 있는 경우 : 레코드는 파티셔너에 의해서 특정한 해쉬값이 생성된다. 이 해쉬값을 기준으로 어느 파티션에 들어갈지 정해진다.
      ※ 토픽에 파티션이 2개가 있는 경우,
        - 서울 - 파티션 0번
        - 부산 - 파티션 1번
        - 울산 - 파티션 0번
      => 동일한 메시지 키를 가진 레코드는 동일한 해쉬값을 만들어 내기 때문에 항상 동일한 파티션에 들어가는 것을 보장한다.
      => 동일한 해쉬값으로 동일한 파티션에 들어가기 때문에 순서를 지켜서 데이터를 처리할 수 있다는 장점이 있다.
        
    - 메시지 키가 없는 경우 : 메시지 키가 없는 경우 라운드 로빈으로 파티션에 들어가게 된다.\
      - 하지만 전통적인 라운드 로빈 방식과는 조금 다르게 동작한다.
      - UniformStickyPartitioner는 프로듀서에서 배치로 모을 수 있는 최대한의 레코드들을 모아서 파티션으로 데이터를 보내게 된다.
        (라운드 로빈 방식 사용)
      - 메시지 키가 없는 데이터들은 파티션에 적절히 분배된다고 생각하면 될 것
      
  ㅇ 커스텀 파티셔너
    - 카프카에서는 커스텀 파티셔너를 만들 수 있도록 Partitioner 인터페이스를 제공하고 있다.
    - 커스텀 파티셔너를 만들면 메시지 키, 메시지 값, 어느 토픽에 따라 데이터를 보낼 수 있을지 정할 수 있다.
    - 언제 사용할 수 있을까? (VIP 고객)
      총 파티션이 10개가 있다면 8개의 파티션은 VIP고객, 2개의 파티션은 일반 고객을 담당하여 VIP고객에 더 데이터 처리량을 몰아주는 형태
      (AMQP에서 우선순의 큐를 만드는 형식과 약간 비슷하다고 생각하면 된다)
```

![image](https://user-images.githubusercontent.com/76584547/125188104-94c23400-e26d-11eb-84ff-c55d62159f5a.png)



### 컨슈머 랙(lag)이란?
---
```
  - 카프카를 운영함에 있어서 아주 중요한 모니터링 지표 중 하나
  - 파티션에 데이터가 하나하나씩 들어가면 오프셋이라는 숫자가 붙게 된다.(0부터)
```

+ 컨슈머 랙(lag)
```
  - "프로듀서가 마지막으로 넣은 offset과 컨슈머가 마지막으로 읽은 offset의 차이"
  - "lag은 여러개가 존재할 수 있다."
  - 이 lag의 숫자를 통해 현재 새당 토픽에 대해 파이프라인으로 연계되어 있는 프로듀서와 컨슈머의 상태에 대해 유추 가능
  - 주로 컨슈머 상태를 볼 때 사용한다.
```
![image](https://user-images.githubusercontent.com/76584547/125189624-f2f21580-e273-11eb-8546-51abfe8feb1e.png)


+ 한 토픽에 여러 파티션이 존재할 경우, 여러 랙(lag)이 존재할 수 있다.
  + 만약 컨슈머 그룹이 1개이고 파티션이 2개인 토픽에서 데이터를 가져간다면 "lag은 2개가 측정"될 수 있다.
  + 랙(lag) 중 높은 숫자의 lag(31)을 "records-lag-max" 라고 부른다.

![image](https://user-images.githubusercontent.com/76584547/125189723-84618780-e274-11eb-9032-b8a3bbe6f355.png)



### 버로우(Burrow)란?
---
```
  - 컨슈머 랙 모니터링 애플리케이션 , 오픈소스 버로우, Go lang
  - 멀티 카프카 클러스터 지원
  - Sliding window를 통한 Consumer의 status 확인
  - HTTP API 제공
```

+ lag을 실시간으로 모니터링 하고 싶은 경우
```
  ㅇ 데이터를 Elasticsearch나 InfluxDB와 같은 저장소에 넣은 뒤 Grafana 대시보드를 통해 확인할 수 있다.
  ㅇ 컨슈머 단위에서 lag을 모니터링하는 것은 아주 위험하고 운영요소가 많이 들어간다.
    => 왜냐하면 컨슈머 로직단에서 lag을 수집하는 것은 컨슈머 상태에 디펜던시가 걸리기 때문이다.
    => 컨슈머가 비정상적으로 종료하게 된다면 더이상 컨슈머는 lag정보를 보낼 수 없기 때문에 더이상 lag을 측정할 수 없다. 
    => 그리고 컨슈머가 추가될 때마다 해당 컨슈머에 lag 정보를 특정 저장소에 저장할 수 있도록 로직을 개발해야한다. (운영이 까다롭다)
  ㅇ 그래서 링크드인에서는 카프카와 함께 랙을 모니터링 하도록 버로우를 내놓았다.
```

+ 멀티 카프카 클러스터 지원
```
  ㅇ 대부분 2개 이상의 카프카 클러스터를 운영하고 있을 것
  ㅇ 이렇게 카프카 클러스터가 여러개라도 Burrow 애플리케이션 1개만 실행해서 연동한다면
  ㅇ 카프카 클러스터들에 붙은 컨슈머의 lag을 모두 모니터링할 수 있다.
```

+ Sliding window를 통한 Consumer의 status 확인
```
  ㅇ Burrow에는 sliding window를 통해서 컨슈머의 status를 'ERROR', 'WARNING', 'OK' 표현할 수 있다.
  ㅇ 'WARNING' : 만약 데이터량이 일시적으로 많아져서 consumer offset이 증가하고 있는 상태
  ㅇ 'ERROR': 만약 데이터량이 많아지고 있는데 consummer가 데이터를 가져가지 않는 상태
```

+ HTTP API 제공
```
  ㅇ Burrow의 정보를 HTTP API를 통해 조회 가능하다
```

+ Burrow 참고 자료 : https://blog.voidmainvoid.net/243


### 서버엔진
-------
```
클라이언트의 요청을 받아 SQL을 처리하는 DB 자체의 기능적인 역할을 담당한다.
```
+ 쿼리 파싱
   + 사용자가 쿼리를 날렸을ㅇ 때, DB가 SQL을 이해할 수 있도록 쿼리를 재구성하는 것
+ 데이터 요청
   + 디스크나 메모리 같은 물리적인 저장장치와 통신하는 스토리지에서 데이터 요청 업무 담당
+ 데이터 처리
   + 스토리지 엔진에서 가져온 데이터를 처리하는 역할
   + Table Join, Group By, Order By와 같은 일반적인 SQL 처리부터
   + Function / Procedure, Trigger, Constraint 등과 같은 기능도 처리  


### 스토리지 엔진
-------
```
서버엔진이 필요한 데이터를 물리 장치에서 가져오는 역할
```
+ Mysql은 다른 DBMS와 다르게 스토리지 엔진이 플러그인 방식으로 동작한다.
   + Mysql 5.5 버전에선 스토리지 엔진 8개가 기본적으로 설치되어 있다.
   ```
   Inno DB, MyISAM, MRG_MYISAM, BLACKHOLE, CSV, MEMORY, FEDERATED, ARCHIVE
   ```
   + Mysql은 다른 상용 DBMS와 다르게 DB엔진에 완벽하게 최적화되어 있지 않다.
   ```
   - 이는 다양한 스토리지 엔진에서 동작할 수 있어야 하기 때문이다. 
   - 그래서 데이터 처리가 일부 비효율적일 수도 있지만 확장성 면에서는 다른 어떠한 DBMS보다 유연하다.
   ```
+ Mysql은 강력한 특징 중 하나는 바로 스토리지 엔진의 다양성이다.
+ 주요 스토리지 엔진 MyISAM, Inno DB, Archive 차이
   + MyISAM
   ```
   - 조회 시 빠른 속도 (풀 텍스트 인덱스 지원)
   - 카운트, 집계(함수) 빠름
   - Table Level Locking
   - Select, Insert, Delete, Update 시 해당 Table 전체 Lock이 걸린다.
   - row 수가 늘어날 수록 엄청 느려진다.
   - 인덱스만 메모리에 올린다.
   ```
   + Inno DB
   ```
   - Order By 압도적으로 빠르다.
   - 대용량 처리 빠름
   - Row Level Locking
   - 인덱스 + 데이터를 모두 메모리에 올린다. (메모리 버퍼 크기 (InnoDB_Buffer_Pool_Size)가 DB 성능에 큰 영향을 미친다.)
   ```
   + Archive
   ```
   - 로그 수집에 적합한 스토리지 엔진
   - 데이터가 메모리상에서 압축되고 압축된 상태로 디스크에 저장하기 때문에 Row Level Locking
   - 단, 한 번 INSERT 된 데이터는 UPDATE,DELETE를 사용할 수 없으며 인덱스를 지원하지 않는다.
   - 원시 로그, 즉 가공이 한 번 필요한 데이터 수집에는 상당히 효율적이다.
   - 테이블 파티셔닝도 지원하므로 일별 또는 우러별 데이터를 관리할 수 있다.
   - 통계 서비스 기초 데이터를 백업할 때 디스크 용량을 1/10으로 절약
   ```
   
### 데이터 처리
-------
```
- Mysql은 SQL을 병렬 처리하지 않는다. 3rd Party 스토리지 엔진을 설치하여 병렬처리를 할 수 있지만,
- 기본적으인 스토리지 엔진은 단일 코어로만 데이터를 처리한다.
- 따라서 Mysql 입장에서는 CPU 코어 개수를 늘리는 Scale-Out보다는 단위 처리량이 좋은 CPU로 Scale-Up하는 것이 훨씬 좋다
```
   + Nested Loop Join 알고리즘을 이용하여 테이블 조인한다.
   ```
   - 선행 테이블 A의 조건 검색 결과값 하나하나를 테이블 B와 비교하여 조인하는 방식이다.
   - 프로그램적으로 풀자면 for문 안에 for문과 윳가하다.
   - 결국 처리할 데이터가 적으면 빠르지만, 테이블 A,B 중 하나라도 연산할 데이터가 많으면 쿼리 효율이 기하급수적으로 떨어진다.
   - 데이터를 처리하면 매번 데이터 접근 요청을 하기 때문에 매우 비효율적이다
   - 이를 개선한게 조인 버퍼를 이용한 Block Nested Loop Join이다.
   ```
   + Block Nested Loop Join (조인 버퍼 도입)
   ```
   - STEP1. 테이블 A의 조인 대상을 찾는다.
   - STEP2. 조인할 데이터를 [조인 버퍼]가 가득 찰 때까지 채운다.
   - STEP3. 테이블 B에 테이블 풀스캔, 인덱스 풀스캔, 인덱스 범위 스캔 등으로 데이터 접근한다.
   - 여기서 테이블 B의 스캔하는 횟수는 "조인 버퍼에 데이터가 적재되는 횟수"와 동일하다.
   ```


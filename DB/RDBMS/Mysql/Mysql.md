
### 서버엔진
-------
```
클라이언트의 요청을 받아 SQL을 처리하는 DB 자체의 기능적인 역할을 담당한다.
```
+ 쿼리 파싱
   + 사용자가 쿼리를 날렸을ㅇ 때, DB가 SQL을 이해할 수 있도록 쿼리를 재구성하는 것
+ 데이터 요청
   + 디스크나 메모리 같은 물리적인 저장장치와 통신하는 스토리지에서 데이터 요청 업무 담당
+ 데이터 처리
   + 스토리지 엔진에서 가져온 데이터를 처리하는 역할
   + Table Join, Group By, Order By와 같은 일반적인 SQL 처리부터
   + Function / Procedure, Trigger, Constraint 등과 같은 기능도 처리  


### 스토리지 엔진
-------
```
서버엔진이 필요한 데이터를 물리 장치에서 가져오는 역할
```
+ Mysql은 다른 DBMS와 다르게 스토리지 엔진이 플러그인 방식으로 동작한다.
   + Mysql 5.5 버전에선 스토리지 엔진 8개가 기본적으로 설치되어 있다.
   ```
   Inno DB, MyISAM, MRG_MYISAM, BLACKHOLE, CSV, MEMORY, FEDERATED, ARCHIVE
   ```
   + Mysql은 다른 상용 DBMS와 다르게 DB엔진에 완벽하게 최적화되어 있지 않다.
   ```
   - 이는 다양한 스토리지 엔진에서 동작할 수 있어야 하기 때문이다. 
   - 그래서 데이터 처리가 일부 비효율적일 수도 있지만 확장성 면에서는 다른 어떠한 DBMS보다 유연하다.
   ```
+ Mysql은 강력한 특징 중 하나는 바로 스토리지 엔진의 다양성이다.
+ 주요 스토리지 엔진 MyISAM, Inno DB, Archive 차이
   + MyISAM
   ```
   - 조회 시 빠른 속도 (풀 텍스트 인덱스 지원)
   - 카운트, 집계(함수) 빠름
   - Table Level Locking
   - Select, Insert, Delete, Update 시 해당 Table 전체 Lock이 걸린다.
   - row 수가 늘어날 수록 엄청 느려진다.
   - 인덱스만 메모리에 올린다.
   ```
   + Inno DB
   ```
   - Order By 압도적으로 빠르다.
   - 대용량 처리 빠름
   - Row Level Locking
   - 인덱스 + 데이터를 모두 메모리에 올린다. (메모리 버퍼 크기 (InnoDB_Buffer_Pool_Size)가 DB 성능에 큰 영향을 미친다.)
   ```
   + Archive
   ```
   - 로그 수집에 적합한 스토리지 엔진
   - 데이터가 메모리상에서 압축되고 압축된 상태로 디스크에 저장하기 때문에 Row Level Locking
   - 단, 한 번 INSERT 된 데이터는 UPDATE,DELETE를 사용할 수 없으며 인덱스를 지원하지 않는다.
   - 원시 로그, 즉 가공이 한 번 필요한 데이터 수집에는 상당히 효율적이다.
   - 테이블 파티셔닝도 지원하므로 일별 또는 우러별 데이터를 관리할 수 있다.
   - 통계 서비스 기초 데이터를 백업할 때 디스크 용량을 1/10으로 절약
   ```
   
### 데이터 처리
-------
```
- Mysql은 SQL을 병렬 처리하지 않는다. 3rd Party 스토리지 엔진을 설치하여 병렬처리를 할 수 있지만,
- 기본적으인 스토리지 엔진은 단일 코어로만 데이터를 처리한다.
- 따라서 Mysql 입장에서는 CPU 코어 개수를 늘리는 Scale-Out보다는 단위 처리량이 좋은 CPU로 Scale-Up하는 것이 훨씬 좋다
```
   + Nested Loop Join 알고리즘을 이용하여 테이블 조인한다.
   ```
   - 선행 테이블 A의 조건 검색 결과값 하나하나를 테이블 B와 비교하여 조인하는 방식이다.
   - "단일 코어"로만 데이터를 처리하기 때문에, Scale-Out이 아닌 "Scale-Up"이 효율적이다.
   - 프로그램적으로 풀자면 for문 안에 for문과 유사하다.
   - 결국 처리할 데이터가 적으면 빠르지만, 테이블 A,B 중 하나라도 연산할 데이터가 많으면 쿼리 효율이 기하급수적으로 떨어진다.
   - 데이터를 처리하면 매번 데이터 접근 요청을 하기 때문에 매우 비효율적이다
   - 이를 개선한게 조인 버퍼를 이용한 "Block Nested Loop Join"이다.
   ```
   + Block Nested Loop Join ("조인 버퍼" 도입)
   ```
   - 테이블 조인 시 필요한 데이터를 메모리에 일시적으로 저장하여 효율적으로 데이터에 접근
   - STEP1. 테이블 A의 조인 대상을 찾는다.
   - STEP2. 조인할 데이터를 [조인 버퍼]가 가득 찰 때까지 채운다.
   - STEP3. 테이블 B에 테이블 풀스캔, 인덱스 풀스캔, 인덱스 범위 스캔 등으로 데이터 접근한다.
   - 여기서 테이블 B의 스캔하는 횟수는 "조인 버퍼에 데이터가 적재되는 횟수"와 동일하다.
   ```

### 데이터 연산을 최소한으로 유도하자
----
   + 불필요한 데이터 정렬과 연산을 줄이자
   ```
      - 불필요한 데이터의 연산과 정렬을 통으로 외부조인하지 말고 조인에 필요한 데이터만
        서브쿼리에서 유지하고 그 후에(줄여진 데이터)로 외부조인하면 성능 업
      - 다수의 조인을 피할 수 없다면 필요한 데이터만 가져와서 데이터를 처리하고 다시 조인하는 것이 포인트
   ```
   
   + Semi Join으로 인한 비효율 제거
   ```
      - Exists와 IN 같은 조인 안에 있는 세미조인을 FROM 절에 외부 조인하고 그 후에 WHERE절로 구분하여 최적화한다. 
      - MYSQL 5.5이하 버전에서만 주의
   ```
   
   + Outer Join이 반드시 필요한지 파악하자
   ```
      - 무분별하게 아우터 조인을 사용하면 성능이 상당히 떨어진다.
      - 위와 동일하게 조건문을 from 서브쿼리에 두고 연산 이후에 아우터 조인을 한다.
   ```
   
### 트랜잭션 Isolation 레벨
---
```
   트랜잭션을 처리할 때 어느 수위까지 데이터의 일관성을 보장해줄 것이냐하는 것
   
   
   ㅇ READ-UNCOMMITTED
   ㅇ READ-COMMITTED
   ㅇ REPEATABLE READ
   ㅇ SERIALIZABLE
   ※ 밑으로 갈 수록 격리수준이 높아지지만 성능이 떨어진다 (데이터 정합성과 성능이 반비례)
```
   
   ### READ-UNCOMMITTED
   ---
   ```
      - 격리 수준이 가장 낮다
      - 한 트랜잭션이 아직 커밋되지 않은 상태임에도 불구하고 변경된 값을 다른 트랜잭션에서 읽을 수 있다.
      - 더티리드 문제, 논 리피터블 리드 문제, 팬텀리드 문제
   ```
   + update 후 커밋을 하지 않았음에도, 변경된 트랜잭션 A의 값을 조회하는 것을 볼 수 있다.
   ![image](https://user-images.githubusercontent.com/76584547/127758928-d6f79277-7108-4fe7-912b-844ff09201b6.png)
   
   + 더티리드 문제(Dirty Read)
   ```
      트랜잭션 A가 만약 트랜잭션을 끝마치지 못하고 롤백한다면 트랜잭션 B는 무효가 된 데이터 값을 읽고 처리하기 때문에 문제가 생긴다.
   ```
   
   
   ### READ-COMMITTED
   ---
   ```
      - 커밋이 완료된 트랜잭션의 변경 사항만 다른  트랜잭션에서 조회 가능
      - 트랜잭션이 이루어지는 동안 다른 사용자는 해당 데이터에 접근이 불가능
      - 논 리피터블 리드 문제, 팬텀리드 문제
   ```
   + 커밋하면 변경된 데이터를 읽어온다.
   ![image](https://user-images.githubusercontent.com/76584547/127759103-f97bf4b8-479a-49cc-ab55-ee0cac1b63a1.png)

   + 논 리피터블 리드 문제(Non-Repeatable Read)
   ```
      위와 같이("히히","허허") 같은 트랜잭션 내에서 select문을 두 번 조회했는데 두 값이 다른 값이 나오는 데이터 불일치 문제.
   ```
   
   ### REPEATEABLE-READ
   ---
   ```
      - READ-COMMITTED와 마찬가지로 커밋이 된 데이터만 읽을 수 있다.
      - READ-COMMITTED와 다른 점은 한 트랜잭션이 조회한 데이터는 트랜잭션이 종료될 때까지 다른 트랜잭션이 변경하거나 삭제 불가
      - SELECT 시 현재 데이터 버전의 스냅샷을 만들고 만든 스냅샷에서 데이터 조회
      - 동일 트랜잭션 내에서 데이터 일관성을 보장.
      - 데이터를 다시 읽으려면 트랜잭션을 다시 시작해야함
   ```
   + 한 번 조회한 트랜잭션이 다른 트랜잭션에 의해 변경,커밋되어도 반복적으로 조회해도 같은 값을 반환한다.
   ![image](https://user-images.githubusercontent.com/76584547/127759195-e94a9eb9-188f-48b2-8249-3b83a0c26942.png)
   
   + Phantom READ 문제
   ```
      - Phantom READ는 Non-Repeatable Read의 한 종류로 조건이 걸렸든 안 걸렸든 select 문을 쓸 때 나타날 수 있는 현상
      - 해당 쿼리로 읽히는 데이터에 들어가는 행위, 새로 생기거나 없어져 있는 현상
   ```
   ![image](https://user-images.githubusercontent.com/76584547/127759288-ccf008d2-e219-41fe-b3fe-3f38e96f1807.png)

   
   ### SERIALIZABLE
   ---
   ```
      - SELECT 문장이 사용하는 모든 데이터에 "공유락"이 걸림
      - 한 트랜잭션에서 사용하는 데이터를 다른 트랜잭션에서 접근 불가
      - 트랜잭션의 ACID 성질이 엄격하게 지켜지나 성능은 가장 떨어진다.
      - 단순 SELECT 만이라도 트랜잭션이 커밋될 때까지 모든 데이터에 잠금이 설정되어 다른 트랜잭션에서 해당 트랜잭션 변경 불가
      
      ※ 공유락 : 다른 트랜잭션은 해당 데이터를 읽을 수는 있으나 수정할 수 없다.
   ```
   
   ### 각 격리 수준에서 발행할 수 있는 문제점
   ---
   
   ![image](https://user-images.githubusercontent.com/76584547/127759395-efd2c555-44b8-4893-909b-4add13bd3730.png)

   
   ### 트랜잭션 전파 타입
   ---
   ```
    부모 트랜잭션이 있냐 없냐에 따라 타입별로 트랜잭션의 경계 설정 가능
   ```
   ![image](https://user-images.githubusercontent.com/76584547/127759431-d5ab9a7d-4ac6-48ef-a453-e370e1539189.png)
   
   + 스프링에서 제공하는 전파 타입 7가지
   
   ![image](https://user-images.githubusercontent.com/76584547/127759449-5ea1ee87-9589-4906-b134-10ee80ccd249.png)

   
### 파티셔닝
---
```
   하나의 커다란 데이터를 여러개의 데이터로 분할 저장할으로써 데이터의 선택 효율을 높이는 기법
```
+ 이와 같이 데이터를 분할 저장하면 특정 데이터를 찾을 때 필요한 데이터 파일만 접근하기 때문에 효율이 높아진다.
   + 특히 InnoDB에서는 Primary Key순으로 데이터가 저장되기 때문에 무작위로 Primary Key를 INSERT 하면 성능이 급격히 저하될 수 있다.
   + 이 경우 테이블에 파티셔닝을 적용하면 비효율을 어느정도 극복할 수 있다.
![image](https://user-images.githubusercontent.com/76584547/127771620-13abf615-6718-41b6-b3c9-e8bc80381ea1.png)

+ 제약사항
```
   1. 파티셔닝 키는 Primary Key와 연관된 칼럼이 있어야한다.
   2. 파티셔닝 사용 시 Unique Key 혹인 Forien Key와 같은 제약 조건을 추가할 수 없다.(단, Unique Key가 Primar Key로 사용하는 경우 제외)
   3. 파티셔닝 적용시 풀텍스트 인덱싱 혹은 스파셜 인덱싱 기능은 사용할 수 없다.
   4. 데이터 조회 시 반드시 파팅셔닝 키가 포함되어야 하며 그렇지 않은 경우 전체 데이터 파일을 스캔한다.
```

+ Primary Key 외에 Unique 속성이 반드시 필요하다면?
```
   - 파티셔닝 때문에 로직이 복잡해질 수 있다.
   - 또한 이노디비인 경우 프라이머리 키의 크기가 커질 수 있기 때문에 전체적인 인덱스 사이즈도 커질 수 있다.
   - 이노디비에서는 프라이머리 키 이외의 보조 인덱스는 프라이머리 키를 값으로 가지기 때문이다
      (색인을 예로 들면 검색어가 인덱스 키가되고, 페이지 번호가 인덱스 값이 된다.)
   - 이러한 제약은 대용량 데이터를 처리하기 위한 어느 정도의 "트레이드 오프"이다"
```

### 통계 테이블 적절히 사용
----
```
   - 데이터 페이징을 위해 테이터 수를 카운트하는데 페이징을 계산 하려면 반드시 전체 데이터 수가 필요하다.
   - 이 경우 해당 조건에 맞는 테이블의 카운트 수만 따로 테이블로 관리하면 서비스 품질과 DB효율이 높아진다.
```
+ 통계성 테이블 추가

<BR/>

![image](https://user-images.githubusercontent.com/76584547/127772833-87708f1d-feec-4213-b7e1-544955139607.png)

+ RED 데이터 카운트 수행
   + 매번 전체 데이터를 카운트 쿼리를 안 날려도 된다. 
```SQL
   SELECT name_count
   FROM log_stat
   WHERE name = 'RED';
```
